#! /usr/bin/env bash

# TODO:
# - filter rows by column value
# - infer path from current branch
# - don't make temp file for awk program
# - handle verbose flag

usage() {
    SCRIPT_NAME=`basename "$0"`
    echo "Usage: $SCRIPT_NAME -s <data_regex_filter> [-f <filename_regex_filter>] [-o <output_column_expr>] [-l <line_limit_per_file>]" 1>&2; 
    echo "" 1>&2; 
    echo "data_regex_filter     : filesnames will be searched for this.  (grep -E \"data_regex_filter\")" 1>&2; 
    echo "filename_regex_filter : file content will be searched for this.  (grep -E \"filename_regex_filter\")" 1>&2; 
    echo "output_column_expr    : specify which columns to output. " 1>&2; 
    echo "line_limit_per_file   : limit the number of results returned per file. (default=10)" 1>&2; 
    echo "" 1>&2; 
    echo "Notes:" 1>&2; 
    echo "- searches all files in current directory is subdirectories (ie. maxdepth=1)" 1>&2; 
    echo "- " 1>&2; 
    echo "" 1>&2; 
    echo "Examples:" 1>&2; 
    printf "\tquery -s 1234\n" 1>&2;
    printf "search all files under working directory for \"1234\"\n" 1>&2;
    printf "\tquery -s \"1234|4321\" -f 201501.*/.*Employee\n" 1>&2;
    printf "search all files under working directory for \"1234\"\n" 1>&2;
    echo "" 1>&2; 
    echo "" 1>&2; 
    echo "" 1>&2; 
    exit 1; 
}

function write_awk_program() {
    # generates an awk program to print formatted columns
    # example: $1="1,3,2,4"
    # -> field_selector="$1,$3,$2,$4"
    # -> print_format="%s|%s|%s|%s_%s,"

    # input: string containing 1 or more column indices
    OUTPUT_COLUMNS="$1";

    # extract column indices from $OUTPUT_COLUMNS; return as comma delimited string
    field_selector=`echo "$OUTPUT_COLUMNS" | grep -E -o "[[:digit:]]+" | xargs -I'{}' printf ",$%s" '{}'`;
    field_selector=${field_selector:1}
    # extract formatting from $OUTPUT_COLUMNS, replace column indices with "%s" for printf
    # print_format=`echo "$OUTPUT_COLUMNS" | grep -E -o "[[:digit:]]+" | xargs -I'{}' printf ",%s" '{}'`;
    print_format=`echo "$OUTPUT_COLUMNS" | sed -E -n "s/([[:digit:]]+)+/%s/pg"`
    print_format=`echo "$OUTPUT_COLUMNS" | grep -E -o "[[:digit:]]+" | xargs -I'{}' printf ",%s" "%s"`;
    print_format=${print_format:1}


    # create awk program as string
    prog=" BEGIN { FS=found_delim } { printf(\"${print_format}\n\", "${field_selector}") } ";
    # echo "columns: "$OUTPUT_COLUMNS;
    # echo "field_selector: $field_selector"
    # echo "print_format: $print_format"
    # echo "awk program: $prog"
    echo "$prog";
}


function formatted_query() {
    FILENAME="$1"
    CONTENT_GREP="$2"
    OUTPUT_COLUMNS="$3"
    LIMIT=$4

    # generate awk program
    awk_program=`write_awk_program "$OUTPUT_COLUMNS"`
    # echo $awk_program;
    # save awk program in temp file.
    prog_file=$HOME"/prog.awk"
    echo "$awk_program" > $prog_file;

    {
        head -n 1 "$FILENAME" |\
            # output selected column headers as csv
            awk -v found_delim=$found_delim -f $prog_file;
        cat $FILE |\
            # filter file lines with grep
            grep -E "$CONTENT_GREP" |\
            # limit matches
            head -n $LIMIT |\
            # output selected columns as csv
            awk -v found_delim=$found_delim -f $prog_file
    }
    #  |\
    # format output as a table
    # column -t -s,
}

function wheres_waldo_output_limit() {
    FILENAME="$1"
    CONTENT_GREP="$2"
    OUTPUT_COLUMNS="$3"
    LIMIT=$4

    # infer delimiter
    found_delim=`delim "$FILENAME"`
    if [ "$found_delim" = "" ];
    then
        printf "${RED}${FILENAME} is not a delimited file.${RESET}\n"
        return 1;
    fi;



    # check if grep returns any matches...
    found=1;
    matched_lines=`cat "$FILENAME" | grep -E "$CONTENT_GREP" | wc -l`;
    if [[ $matched_lines -gt 0 ]];
    then
        found=0;

        printf "${GREEN}%s${RESET} (found: %s lines, delimiter: '%s')\n" "${FILENAME}" "${matched_lines}" "${found_delim}";
        table=`formatted_query "$FILENAME" "$CONTENT_GREP" "$OUTPUT_COLUMNS" "$LIMIT"`
        { printf $CYAN; printf "$table" | column -t -s, | head -n 1; printf $RESET"\n"; }
        { printf $CYAN; printf "$table" | column -t -s, | tail -n 1; printf $RESET; }
        # highlight grep matches in selected columns of filtered lines
            # grep --color -E $content_grep_or
        printf "${RESET}\n";re
    fi;

    return $found;
}


while getopts ":s:f:o:l:v:" ARGS; do
    case "${ARGS}" in
        s)
            s=${OPTARG}
            # ((d == "," || d == "\t")) || usage
            ;;
        f)
            f=${OPTARG}
            ;;
        o)
            o=${OPTARG}
            ;;
        l)
            l=${OPTARG}
            ;;
        v)
            v=${OPTARG}
            ;;
        *)
            usage
            ;;
    esac
done
shift $((OPTIND-1))

if [ -z "${s}" ]; then
    usage
else
    printf "\n\nsearching for: ${RED}${s}\n${RESET}"
fi
# set defaults for optional params
if [ -z "${f}" ]; then
    f=".*";
fi
if [ -z "${o}" ]; then
    printf "${YELLOW}WARNING: defaulting to -o 1,2,3,4${RESET}\n"
    o="1,2,3,4";
fi
if [ -z "${l}" ]; then
    l="20";
fi

function debug() {
    printf "%s : %s\n" "s" "$s";
    printf "%s : %s\n" "f" "$f";
    printf "%s : %s\n" "o" "$o";
    printf "%s : %s\n" "l" "$l";
}

function query() {
    file_arg="$1"
    search_arg="$2";
    output_arg="$3";
    limit_arg="$4";
    found_in_files=()
    FILES=`find * -maxdepth 1 -type f | grep -E "${file_arg}"`
    while read FILE; do
            wheres_waldo_output_limit "${FILE}" "${search_arg}" "${output_arg}" ${limit_arg};
            found=$?;
            if [[ $found -eq 0 ]]; then
                found_in_files+=("$FILE");
            fi;
    done <<< "$FILES";
    file_found_count=${#found_in_files[@]}
    if [[ $file_found_count -gt 0 ]];
    then
        printf "\n${GREEN}found in %d files: \n${RESET}" $file_found_count;
        for found_file in ${found_in_files[@]}; do
            printf "\t%s\n" "$found_file";
        done;
    else
        printf "\n\n${YELLOW}NOT found${RESET}\n";
    fi;

}

query "$f" "$s" "$o" "$l";
# debug;