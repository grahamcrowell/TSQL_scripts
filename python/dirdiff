#! /usr/bin/python
# dirdiff
import hashlib
import sys
import os
import logging
import inspect
import UserDict
import itertools
import curses
import time
import time
import json
import collections
import timing # https://stackoverflow.com/questions/1557571/how-do-i-get-time-of-a-python-programs-execution/1557906#1557906

# create logger
logger = logging.getLogger(__file__)
logger.setLevel(logging.DEBUG)

# create console handler and set level to debug
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)


# create formatter
formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
formatter = logging.Formatter('%(name)s - %(levelname)s - %(message)s')

# add formatter to ch
ch.setFormatter(formatter)

# add ch to logger
logger.addHandler(ch)


# @TODO add colours to debug output
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def alert(msg):
    return "{}{}{}".format(bcolors.FAIL, msg, bcolors.ENDC)


class DataFile:
    def __init__(self, root_path, abspath):
        self.abspath = abspath
        self.root_path = root_path
        self.relpath = os.path.relpath(self.abspath, self.root_path)
        self.size = fileSize(abspath)
        self.hash = fileHash(abspath)

    def __str__(self):
        return "DataFile({root_path}, {relpath})".format(**self.__dict__)

    def __repr__(self):
        return str(self)

    def __eq__(self, rhs):
        return self.hash == rhs.hash and self.relpath == self.relpath

    def __hash__(self):
        return hash(self.hash)


class DataDir(UserDict.IterableUserDict):
    def __init__(self, root_path):
        self.root_path = root_path
        (UserDict.IterableUserDict).__init__(self)

    def process(self):
        _data_files = []
        for (parent_path, sub_folder_names, file_names) in os.walk(self.root_path):
            file_paths = map(lambda file_name: os.path.join(parent_path,file_name), file_names)
            _data_files = map(lambda file_path: DataFile(self.root_path,file_path), file_paths)
            for data_file in _data_files:
                if data_file.hash not in self:
                    self[data_file.hash] = []
                self[data_file.hash].append(data_file)
    def getPath(self, hash_str):
        return map(lambda data_file: data_file.relpath, self[hash_str])

    def getPaths(self, hash_strs=None):
        if (type(hash_strs) is list):
            print("lookup hash list")
            paths = []
            for hash_str in hash_strs:
                paths.extend(self.getPath(hash_str))
            return paths
        else:
            raise NotImplementedError("getPaths({})".format(type(hash_str)))

class DirDiff:
    def __init__(self, src_path, dst_path, only_src, not_moved, moved, only_dst):
        self.ordered_dict = collections.OrderedDict()
        self.ordered_dict["Source Path"] = src_path
        self.ordered_dict["Destination Path"] = dst_path
        self.ordered_dict["Source Only"] = only_src
        self.ordered_dict["Destination Only"] = only_dst
        self.ordered_dict["Both but moved"] = moved
        self.ordered_dict["Both and not moved"] = not_moved

    def __str__(self):
        return json.dumps(self.ordered_dict, indent=2)

    def __repr__(self):
        return self.__str__()

class DataDirDiffer:
    def __init__(self, src, dst):
        self.src = src
        self.dst = dst
        self.src_data_dir = DataDir(self.src)
        self.dst_data_dir = DataDir(self.dst)
        print("process and diff")
        self.src_data_dir.process()
        self.dst_data_dir.process()
        self.not_moved, self.moved = self._intersecting()
        self.source_not_destination = self._missingInDestination()
        self.destination_not_source = self._missingFromSource()
        self.moved_paths_pairs = []
        for moved_hash in self.moved:
            self.moved_paths_pairs.append(self.getMovedPathsPair(moved_hash))

    def getMovedPathsPair(self, moved_hash):
            return (self.src_data_dir.getPath(moved_hash), self.dst_data_dir.getPath(moved_hash))

    def getDiff(self):
        print("getDiff")
        return DirDiff(
                self.src_data_dir.root_path,
                self.dst_data_dir.root_path,
                self.src_data_dir.getPaths(self.source_not_destination),
                self.src_data_dir.getPaths(self.not_moved),
                self.moved_paths_pairs,
                self.dst_data_dir.getPaths(self.destination_not_source))

    def _missingInDestination(self):
        return [hash_str for hash_str in set(self.src_data_dir.keys()) - set(self.dst_data_dir.keys())]

    def _missingFromSource(self):
        return [hash_str for hash_str in set(self.dst_data_dir.keys()) - set(self.src_data_dir.keys())]

    def _intersecting(self):
        intersecting_hashs = [src_dst_hash for src_dst_hash in set(self.src_data_dir.keys()) & set(self.dst_data_dir.keys())]
        moved_hashs = []
        not_moved_hashs = []
        for file_hash in intersecting_hashs:
            src_paths = set(self.src_data_dir.getPath(file_hash))
            dst_paths = set(self.dst_data_dir.getPath(file_hash))
            if src_paths != dst_paths:
                moved_hashs.append(file_hash)
            else:
                not_moved_hashs.append(file_hash)
        return not_moved_hashs, moved_hashs

    def __repr__(self):
        return "DataDirDiffer({}, {})".format(self.src, self.dst)







class DirDifferReport(DataDirDiffer):
    global version_string
    global SPLASH
    global FOLDERS
    version_string = "0.0a"
    SPLASH = """


     | **************************** |
     | Folder Comparison            | 
     | (generated by dirdiff v{version_string}) |
     | **************************** |
""".format(version_string=version_string)
    FOLDERS = """
<source>       = {source_abspath}
<destination>  = {destination_abspath}
"""


    def __init__(self, src, dst):
        DataDirDiffer.__init__(self, src, dst)

    def apply(self, msg):
        return msg.format(**self.__dict__)

    def __str__(self):
        out = self.apply(SPLASH) + self.apply(FOLDERS)
        """
Folder Comparison:

Source: {}
Destination: {}

Moved:
{}
"""
        return out




def readableFileSize(byte_count):
    """
    @brief      formats number of bytes into human readable size with units
    @param      byte_count  number of bytes
    @return     human readable file size with units
    """
    for x in ['bytes', 'KB', 'MB', 'GB', 'TB']:
        if byte_count < 1024.0:
            return "%3.1f %s" % (byte_count, x)
        byte_count /= 1024.0


def fileSize(file_path):
    """
    @brief      human readable file size
    @param      file_path  The file path
    @return     human readable file size with units
    """
    if os.path.isfile(file_path):
        file_info = os.stat(file_path)
        return readableFileSize(file_info.st_size)


def fileHash(file_path):
    """
    @brief      compute hash of a file at file_path.
    @param      file_path  The file path
    @return     Attempts to hash a file assumed to exist and be readable.
                Exceptions are caught and logged.
    """
    # timing.log("hashing: {} {}".format(file_path, fileSize(file_path)))
    hash_str = ""
    try:
        BLOCKSIZE = 65536
        hasher = hashlib.md5()
        with open(file_path, 'rb') as afile:
            buf = afile.read(BLOCKSIZE)
            while len(buf) > 0:
                hasher.update(buf)
                buf = afile.read(BLOCKSIZE)
        hash_str = hasher.hexdigest()
        return hash_str
    except Exception as e:
        method_name = inspect.stack()[0][3]
        logger.warning("failed to hash file: {}\n\t{}".format(file_path,e))


def usage():
    usage_msg = ""
    print(usage_msg)

def process(lhs=None, rhs=None):
    if len(sys.argv) == 3:
        # logger.info("starting:\n\tsys.argv[1] = {}\n\tsys.argv[2] = {}\n\t".format(sys.argv[1],sys.argv[2]))
        lhs = sys.argv[1]
        rhs = sys.argv[2]
    else:
        usage()
        lhs = "/Users/gcrowell/TEST_DATA/esldata/mock_tenant_root"
        rhs = "/Users/gcrowell/TEST_DATA/esldata/mock_tenant_root2"
    dir_diff = DataDirDiffer(lhs, rhs)
    diff = dir_diff.getDiff()
    print(diff)


def main():
    process()


if __name__ == '__main__':
    main()
