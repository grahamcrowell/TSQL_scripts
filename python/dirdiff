#! /usr/bin/python 
# dirdiff
import hashlib,sys,os,logging,inspect,UserDict
import timing

# create logger
logger = logging.getLogger(__file__)
logger.setLevel(logging.DEBUG)

# create console handler and set level to debug
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)


# create formatter
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
formatter = logging.Formatter('%(name)s - %(levelname)s - %(message)s')

# add formatter to ch
ch.setFormatter(formatter)

# add ch to logger
logger.addHandler(ch)

# @TODO add colours to debug output
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

class DataFile:
    def __init__(self, data_root_path, file_absolute_path):
        self.file_absolute_path = file_absolute_path
        self.data_root_path = data_root_path
        self.file_relative_path = os.path.relpath(self.file_absolute_path, self.data_root_path)
        self.size = fileSize(file_absolute_path)
        self.hash = fileHash(file_absolute_path)

    def __str__(self):
        return "DataFile({data_root_path}, {file_relative_path})".format(**self.__dict__)
    def __repr__(self):
        return str(self)
    def __eq__(self, rhs):
        return self.hash == rhs.hash
    def __hash__(self):
        return hash(self.hash)

class DataDir(UserDict.IterableUserDict):
    def __init__(self, root_path):
        self.root_path = root_path
        self.data_files = {}
        (UserDict.IterableUserDict).__init__(self)

    def process(self):
        _data_files = []
        for (parent_path, sub_folder_names, file_names) in os.walk(self.root_path):
            file_paths = map(lambda file_name: os.path.join(parent_path,file_name), file_names)
            _data_files = map(lambda file_path: DataFile(self.root_path,file_path), file_paths)
            for data_file in _data_files:
                print(data_file)
                if data_file.hash not in self.data_files:
                    self.data_files[data_file.hash] = []
                    self[data_file.hash] = []
                self.data_files[data_file.hash].append(data_file)
                self[data_file.hash].append(data_file)

        # self.data_files.update(_data_files)

class DataDirDiff:
    def __init__(self, src, dst):
        self.src = src
        self.dst = dst
        self.src_data_dir = DataDir(self.src)
        self.dst_data_dir = DataDir(self.dst)
    def process(self):
        self.src_data_dir.process()
        self.dst_data_dir.process()
    def missingInDestination(self):
        return [self.src_data_dir[src_hash] for src_hash in set(self.src_data_dir.keys()) - set(self.dst_data_dir.keys())]
    def movedInDestination(self):
        for src_hash in set(self.src_data_dir.keys()) & set(self.dst_data_dir.keys()):
            pass
    def __str__(self):
        return "DataDirDiff({}, {})".format(self.src, self.dst)

def readableFileSize(byte_count):
    """
    @brief      formats number of bytes into human readable size with units
    
    @param      byte_count  number of bytes
    
    @return     human readable file size with units
    """
    for x in ['bytes', 'KB', 'MB', 'GB', 'TB']:
        if byte_count < 1024.0:
            return "%3.1f %s" % (byte_count, x)
        byte_count /= 1024.0


def fileSize(file_path):
    """
    @brief      human readable file size
    
    @param      file_path  The file path
    
    @return     human readable file size with units
    """
    if os.path.isfile(file_path):
        file_info = os.stat(file_path)
        return readableFileSize(file_info.st_size)


def fileHash(file_path):
    """
    @brief      compute hash of a file at file_path.
    
    @param      file_path  The file path
    
    @return     Attempts to hash a file assumed to exist and be readable.  Exceptions are caught and logged.
    """
    # timing.log("hashing: {} {}".format(file_path, fileSize(file_path)))
    hash_str = ""
    try:
        BLOCKSIZE = 65536
        hasher = hashlib.md5()
        with open(file_path, 'rb') as afile:
            buf = afile.read(BLOCKSIZE)
            while len(buf) > 0:
                hasher.update(buf)
                buf = afile.read(BLOCKSIZE)
        hash_str = hasher.hexdigest()
        return hash_str
    except Exception as e:
        method_name = inspect.stack()[0][3]
        logger.warning("failed to hash file: {}\n\t{}".format(file_path,e))

def usage():
    print("learn to drive")

def main():
    if len(sys.argv) == 3:
        logger.info("starting:\n\tsys.argv[1] = {}\n\tsys.argv[2] = {}\n\t".format(sys.argv[1],sys.argv[2]))
        lhs = sys.argv[1]
        rhs = sys.argv[2]
        dir_diff = DataDirDiff(lhs, rhs)
        dir_diff.process()
        dir_diff.missingInDestination()
        return dir_diff
    else:
        usage()

if __name__ == '__main__':
    main()



